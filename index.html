<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Dice Path Test</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
html, body {
  margin: 0;
  height: 100%;
  overflow: hidden;
  background: #020617;
}
canvas { display: block; }
#hint {
  position: fixed;
  bottom: 16px;
  left: 50%;
  transform: translateX(-50%);
  color: #94a3b8;
  font-family: Arial;
  font-size: 13px;
}
</style>
</head>

<body>
<div id="hint">Swipe / A / D to move dice on path</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

<script>
let scene, camera, renderer;
let dice, path;
let t = 0.5;
let targetT = 0.5;
let bounce = 0;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020617);

  camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 100);
  camera.position.set(0, 4, 10);
  camera.lookAt(0, 1.2, 0);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(devicePixelRatio);
  document.body.appendChild(renderer.domElement);

  // LIGHT
  scene.add(new THREE.AmbientLight(0xffffff, 1.2));
  const dir = new THREE.DirectionalLight(0xffffff, 1.5);
  dir.position.set(5, 10, 5);
  scene.add(dir);

  // GRID
  scene.add(new THREE.GridHelper(50, 50, 0x38bdf8, 0x1e40af));

  // PATH
  path = new THREE.CatmullRomCurve3([
    new THREE.Vector3(-6, 1.1, 0),
    new THREE.Vector3(0, 1.5, -1.2),
    new THREE.Vector3(6, 1.1, 0)
  ]);

  const points = path.getPoints(80);
  const geo = new THREE.BufferGeometry().setFromPoints(points);
  const mat = new THREE.LineBasicMaterial({ color: 0x38bdf8 });
  const line = new THREE.Line(geo, mat);
  scene.add(line);

  // DICE
  dice = new THREE.Mesh(
    new THREE.BoxGeometry(2.2, 2.2, 2.2),
    new THREE.MeshStandardMaterial({ color: 0x22c55e })
  );
  scene.add(dice);

  // INPUT
  window.addEventListener("keydown", e => {
    if (e.key === "a" || e.key === "ArrowLeft") targetT = 0;
    if (e.key === "d" || e.key === "ArrowRight") targetT = 1;
    if (e.key === " ") targetT = 0.5;
  });

  let touchStartX = 0;
  window.addEventListener("touchstart", e => {
    touchStartX = e.touches[0].clientX;
  });

  window.addEventListener("touchend", e => {
    const dx = e.changedTouches[0].clientX - touchStartX;
    if (Math.abs(dx) < 40) targetT = 0.5;
    else targetT = dx < 0 ? 0 : 1;
  });

  window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
}

function animate() {
  requestAnimationFrame(animate);

  // SNAP
  t += (targetT - t) * 0.08;

  // BOUNCE
  bounce += Math.abs(targetT - t) * 0.15;
  const y = Math.sin(bounce) * 0.15;

  const p = path.getPoint(t);
  dice.position.set(p.x, p.y + y, p.z);
  dice.rotation.z -= (targetT - t) * 2;

  renderer.render(scene, camera);
}
</script>
</body>
</html>
